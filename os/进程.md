fork: fork函数启动一个新的进程，前面我们说过，这个进程几乎是当前进程的一个拷贝：子进程和父进程使用相同的代码段；子进程复制父进程的堆栈段和数据段。
这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，
但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。它们再要交互信息时，只有通过进程间通信来实现

写时复制来源：
如果一个大程序在运行中，它的数据段和堆栈都很大，一次fork就要复制一次，那么fork的系统开销不是很大吗？其实UNIX自有其解决的办法，
大家知道，一般CPU都是以"页"为单位来分配内存空间的，每一个页都是实际物理内存的一个映像，象INTEL的CPU，
其一页在通常情况下是 4086字节大小，而无论是数据段还是堆栈段都是由许多"页"构成的，fork函数复制这两个段，
只是"逻辑"上的，并非"物理"上的，也就是说，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，
当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的" 页"从物理上也分开。系统在空间上的开销就可以达到最小


因为创建进程需要复制非常多的东西，所以如果全都复制的话，效率会非常低也非常消耗内存资源。所以，
在真正创建进程的时候采用的是一种称为写时复制(copy-on-write，COW)的技术来降低这种复制开销。
内核在创建子进程的时候，内核会将父子进程的虚拟地址空间的数据页指向同一物理内存的数据页，
并且将其标记为只读，这样就不会复制这些数据，当父或子进程要读取这些数据的时候，可以直接从物理内存中读取，
而当父或子进程需要修改这些数据的时候，内核才将这个数据页拷贝到父或子进程的地址空间，
这样修改的那一页数据只会影响各进程自身，而不会影响其它进程。这就是写时复制技术。



文件描述符表：每个进程都有一个属于自己的文件描述符表。该表记录进程打开的文件。它的表项里面有一个指针，指向存放在内核空间的文件表中的一个表项。它向用户提供一个简单的文件描述符，使得用户可以通过方便地访问一个文件
文件表：文件表存放在内核空间，由系统里的所有进程共享。
索引节点表inode(index node)：索引结点表也存放在内核空间，由所有进程所共享


不同进程打开同一文件：文件表会存在两个表项，两个表项都指向同一个索引节点表项
同一京城多次打开同一文件：每打开一次同一个文件，内核就会在文件表中增加一个表项。这是因为每次open文件时使用了不同的读写权限，而读写权限是保存在文件表表项里面的