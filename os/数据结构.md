数据项是数据不可分隔的最小单位
数据元素是组成数据的，具有一定意义的基本单位，n个数据项 组成 数据元素。例如人类的数据元素是人
数据对象: 是性质相同的数据元素的集合，是数据的子集，性质相同：数据元素具有相同数量和类型的数据项

#### 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合
逻辑结构 是指数据对象中数据元素之间的关系
1 集合结构
2 线性结构，排成一条直线，元素和线上的点一一对应
3 树形结构，存在1对多的层次关系
4 图形结构 存在多对多的关系

物理结构 是数据的逻辑结构在计算机中的存储方式，也叫存储结构
1 顺序存储结构 把数据元素放在地址连续的存储单元里，元素关系保持和逻辑结构中的关系一致
2 链式存储结构 把数据元素随意放在存储单元，可以是连续的，也可以不连续，每个数据元素会记录下一个元素的地址


#### 算法：
定义:算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。

算法特性：
输入和输出，有穷性，确定性，可行性

设计要求：
正确性，可读性，健壮性，高效率和低存储量


#### 算法时间复杂度
在算法分析前，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T（n）的数量级。
算法时间复杂度，记做：T（n）= O（f(n)）,表示随着问题规模n的增大，算法执行时间的增长率和执行次数的增长率相同
f(n)是问题规模n的执行次数函数

推导大O阶：对执行次数函数进行推导
1 用常数1取代运行次数中的所有加法常数
2 在修改后的运行次数中，只保留最高阶项
3 如果存在最高阶项，则去除与则个项相乘的常数

常数阶：执行次数不会随着n的变大而发生变化 叫做执行时间恒定算法，称之为时间复杂度是O(1)
线性阶：O(n)
平方阶：O(n^2)
对数阶：O(logn)
nlogn阶: O(nlogn)
立方阶：O(n^3)
指数阶：O(2^n)
阶乘阶：O(n!) 
0(1) < O(logn) < O(n) < O(nlogn) < 0(n^2 ) < 0(n^3 ) < O(2^n) < O(n!) < O(n^n)

#### 算法空间复杂度
算法空间复杂度是通过计算算法所需的存储空间所得，公式：S(n) = O(f(n))，n是问题规模，f(n)是n所占存储空间的函数

#### 线性表
定义：0个或多个数据元素的有限序列（序列：有序的队列）

顺序存储结构：
0 需要预先设定长度，可能造成空间浪费
1 在读存数据时，不管是哪个位置，时间复杂度都是O(1) （因为每个数据元素的地址是可以计算出来的）
2 插入或删除时，时间复杂度都是 O(n) （插入或删除时，最差的情况就是变动第一个，后面的数据元素位置都要变化）
3 适宜存放频繁查找，少插入和删除的数据

链式存储结构：
-1 动态长度
0 数据元素的存储映像（结点） = 数据域（存放数据）+ 指针域（存放下个节点的地址）
1 头指针：存放链表的第一个节点位置，无论链表是否为空，头指针必不为空，是组成链表的必要元素,
2 头结点：为了方便操作，会在单链表的第一个节点前附设一个节点，叫做头结点，可以用来存放链表长度等信息，他的指针域是头指针，指向第一个节点
3 最后一个节点的指针域为空指针
4 注意：插入时，必须先将新节点的指针指向下个节点，再把上个节点的指针指向新节点（new->next=p->next p->next=new），不可以弄反（p->next=new new->next=p->next 导致 n->next=n 错误）
5 时间复杂度：如果是单次操作遍历查找或插入删除，时间复杂度都是O(n)，但是如果是在某个位置一次性插入或删除n个元素时，时间复杂度就是O(1)了，因为只需要改变节点的头尾指针
6 适宜存放少查找，频繁插入和删除的数据

静态链表：
1 定义：用数组描述的链表（在没有指针的语言可用该方式大概地实现单链表的功能）
2 每个数组元素带有data和cur(游标)两个属性
3 第一个元素的cur指向备用链表（空闲的所有位置）的第一个节点的下标，最后一个元素的cur指向第一个链表节点的下标

循环链表
1 定义：由单链表的终端节点的指针指向第一个结点（可以是头结点，也可以不用头结点）的地址，形成一个环的链表

双向链表：
1 定义：在单链表的基础上再加一个指向前一个节点地址的指针  前指针prior 后指针next
2 代价：在插入或删除节点的时候需要同时变动前后指针
2 双向循环链表的头结点前指针指向尾节点地址


#### 栈
1 定义：限定仅在表尾进行插入和删除操作的线性表
2 特点：后进先出（LIFO:last in first out）
3 抽象数据类型
```
ADT 栈（stack）
DATA 
	同线性表。元素具有相同类型，相邻元素具有前顾后继的关系
OPeration
    InitStack (*S) 初始化操作，建立一个空栈S
	DestroyStack (*S) 若栈存在，销毁他
	ClearStack (*S) 清空栈
	StackEmpty (*S) 若栈为空，返回true，否则返回false
	GetTop (S *e) 若栈存在，用e返回栈顶元素
	Push (*S, e) 若栈存在，插入新元素e到栈顶，并成为栈顶元素
	Pop (*S, *e) 删除栈S中栈顶元素，并用e返回其值
	StackLength (S) 返回栈S的元素个数
```


顺序存储结构
1 栈底下标为0，栈顶下标为size-1，top指示栈顶元素在栈中的位置，top=-1表示空栈，top=4表示栈满
2 两栈共享空间：适用于两个具有相同元素类型，一个在增长，另一个在减少的栈，对空间需求有相反关系
3 因为只能操作栈顶元素，所以时间复杂度都是O(1),缺点是需要提前固定栈空间大小


链式存储结构，简称链栈
1 结构:数据+指针，指针指向下一个节点
2 因为只能操作栈顶元素，所以时间复杂度都是O(1),可动态长度，但是指针域增加了内存的开销

栈的应用
1 递归：斐波那契数列（Fibonacci）：当n=0时，f(n)=0；当n<=1, f(n)=1；n>=2时，f(n) = f(n-1) + f(n-2)

2 四则运算表达式执行顺序：
中缀表达式-》后缀表达式：
规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分 
      若是符号，则判断其与栈顶符号的优先级，是右括号则优先于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出 并将当前符号进栈，一直到最终输出后缀表达式为止。
实际：栈用来进出运算的符号
参考： http://www.nowamagic.net/librarys/veda/detail/2307

后缀表达式-》结果：
规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。
实际：栈用来进出运算的数字



#### 队列
1 定义：只允许从一端进去，从另一端删除操作的线性表
2 特点：先进先出（FIFO: first in first out）
3 抽象数据类型
```
ADT 队列（queue）
Data
	同线性表。元素具有相同类型，相邻元素具有前顾后继的关系
OPeration
	InitQueue (*Q) 初始化操作，建立一个空队列
	DestroyQueue (*Q) 若队列存在，销毁它
	ClearQueue (*Q) 清空队列
	QueueEmpty (Q) 队列为空返回true，否则返回false
	GetHead (*Q, e) 若队列存在且非空，返回队头元素
	EnQueue (*Q, e) 往队列插入新元素e，并成为队尾元素
	DeQueue (*Q, e) 删除队头元素e，并返回其值
	QueueLength (Q) 返回队列长度
```

顺序存储结构
1 插入时间复杂度为O(1)，删除时间复杂度为O(n)
2 循环队列(为了避免插入和删除时需要移动数据)：环型队列，当队列最后一个位置满了，队尾指针可以指向队列第一个为空的位置，如果第一个位置不为空，那队列必须留空最后一个位置给队尾指针
front队头指针 
rear队尾指针，指向队尾元素的下一个位置
队满条件：(rear+1)%queueSize=front
队空条件：rear=front
时间复杂度都是O(1)

链式存储结构
1 等同于只能尾进头出的单链表
2 插入和删除的时间复杂度为O(1)

#### 字符串
1 定义：由0个或多个字符组成的有限序列
2 抽象数据类型
```
ADT 串(string) 
Data 
	串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。
Operation
	StrAssign (T, *chars) :生成一个其值等于字符常量 chars 的串T
	StrCopy (T, S)：串存在，由S复制得T
	ClearStrinq (S)：串存在，将串清空
	StringEmpty (S)：若串为空，返回 true ，否则返回 false
	StrLength (S)：返回串的元素个数，即串的长度。
	StrCompare (S, T)：比较大小，S>T ，返回>0 ，S=T ，返回 O. S<T ，返回<0
	Concat(T, S1, S2): 字符串拼接S1,S2，返回T
	SubString (Sub S, pos, len): 返回子串
	Index (S, T, pos): 返回子串在主串第一次出现的位置，否则返回0
	Rep1ace (S, T, V) : 替换匹配的子串
	StrInsert (5, pos, T ): 在指定位置插入子串
	StrDelete (5, pos, len)：在指定位置删除指定长度子串
endADT
```

朴素模式匹配算法：单纯的11比对

KMP匹配算法：待学习


#### 树
概念：
1 根节点 双亲节点 叶节点（终端节点） 分支节点（非终端节点）
2 森林：n棵不相交的树的集合

存储结构：
1 双亲表示法
节点结构：下标 + 数据 + 双亲域
双亲域(parent)：指针指向双亲的下标，没有则为-1
最左孩子域(firstchild)：指针指向最左孩子域，没有为-1
兄弟域(rightsib):指针指向右边的第一兄弟节点下标，没有为-1

2 孩子表示法

3 孩子兄弟表示法

二叉树：
定义：每个节点最多只有两个子树，子树区分左右顺序

特殊二叉树：
1 斜树：每个结点都只能有左子树或右子树，统称斜树
2 满二叉树：除了叶子结点，每个节点都有左右子树
3 完全二叉树：若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层从右向左连续缺若干结点，这就是完全二叉树，（或者理解为上到下，从左到右一定是连续的）

二叉树五大性质（待学习）：


二叉树存储结构：
1 顺序存储结构
按照编号存放，空节点也需用^占据空间，所以一般适合用来存储完全二叉树，否则很容易造成空间浪费


2 链式存储结构：
lchild + data + rchild ,lchild指针指向左孩子结点，rchild指针指向有孩子结点，为空则^表示

二叉树遍历
概念：是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅访问一次
性质：
己知前序遍历序列和中序遍历序列，可以唯一确定 棵二叉树 （前序遍历序列的第一个编号是根节点编号）
已知后序遍历序列和中序遍历序列，可以唯 确定一棵 叉树 （后续遍历序列的最后一个编号是根节点编号）

1 前序遍历（核心思想：根节点-->左子树-->右子树）
```
void PreOrderTraverse(BiTree T)
{
	if (T === null) {
		return;
	}
	
	printf("%c", T->data); //显示结点数据，可改为其他对结点的操作
	PreOrderTraverse(T->lchild);  //遍历左子树
	PreOrderTraverse(T->rchild);  //遍历右子树
}
```

2 中序遍历（核心思想：左子树-->根节点-->右子树）
```
void InOrderTraverse(BiTree T)
{
	if (T === null) {
		return;
	}
	
	PreOrderTraverse(T->lchild);  //遍历左子树
	printf("%c", T->data); //显示结点数据，可改为其他对结点的操作
	PreOrderTraverse(T->rchild);  //遍历右子树
}
```

3 后序遍历（核心思想：左子树-->右子树-->根节点）
```
void PostOrderTraverse(BiTree T)
{
	if (T === null) {
		return;
	}
	
	PreOrderTraverse(T->lchild);  //遍历左子树
	PreOrderTraverse(T->rchild);  //遍历右子树
	printf("%c", T->data); //显示结点数据，可改为其他对结点的操作
}
```

线索二叉树 = 二叉树 + 线索化
概念：在链式二叉树的基础上，将空指针改为填充该结点的前驱和后继，并加上ltag，rtag区分左右孩子指针和前驱后继，tag为0 表示孩子指针，为1表示前驱后继
结构：lchild + ltag + data + rtag + rchild  
线索化：对二叉树以某种次序遍历使其变为线索二叉树的过程

平衡二叉树（AVL树：三个创建人的名字首字母） [参考链接](https://zhuanlan.zhihu.com/p/56066942)
概念：一棵高度平衡的二叉排序树
特征：
1 可以是空树
2 结点的左右子树深度差小于等于1 （深度差称为平衡因子）

平衡因子（BF，Balance Factor）：二叉树上结点的左子树深度减去右子树深度值，平衡二叉数的BF值只能是-1,0,1

最小失衡子树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。
也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。

平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的。根据旋转的方向有两种处理方式，左旋（BF为负<-1） 与 右旋 （BF为正>1）。























































































