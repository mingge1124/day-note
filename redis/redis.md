### redis

#### 底层数据结构
---
##### SDS(simple dynamic string)：简单动态字符串，默认的字符串表示
定义：
```
struct sdshdr {
	//记录buf数组中已使用字节的数量
	int len;
	//记录buf数组中未使用字节的数量
	int free;
	//字节数组，用于保存字符串
	char buf[];
}
```
优点：
1. 获取字符串长度复杂度为O(1)
2. 杜绝缓冲区溢出，SDS API进行字符串修改时，会根据记录的len属性判断内存空间是否满足需求，不满足则会先扩展空间再修改
3. 减少修改字符串的内存重新分配次数，
4. 二进制安全
5. 兼容部分C字符串函数

##### 链表
listNode定义
```
typedef struct listNode{
	//前置节点指针
	struct listNode *prev;
	//后置节点指针
	struct listNode *next;
	//节点值，value设置为void*，是因为这样可以保存各种不同类型的值，这就形成了一种多态，使得list中的dup、free、match函数都可以根据节点值来设置类型特定函数
	void *value;
}listNode;
```

list定义
```
typedef struct list{
     //表头节点
     listNode *head;
     //表尾节点
     listNode *tail;
     //链表所包含的节点数量
     unsigned long len;
     //节点值复制函数
     void (*dup) (void *ptr);
     //节点值释放函数
     void (*free) (void *ptr);
     //节点值对比函数
     int (*match) (void *ptr,void *key);
}list;
```

应用场景：
1. 当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现

特性：
1. 双端，获取头尾节点时间复杂度为O(1)
2. 无环，头结点的prev指针和尾节点的next指针都指向null
3. 获取链表长度时间复杂度为O(1)
4. 多态，链表节点使用 `void*` 指针来保存节点值，可以保存各种不同类型的值。

##### 字典
概念：又称为符号表或者关联数组、或映射（map），是一种用于保存键值对的抽象数据结构，字典中的每一个键 key 都是唯一的，通过 key 可以对值来进行查找或修改，Redis的字段使用哈希表作为底层实现
哈希表结构定义：
```
typedef struct dictht{
     //哈希表数组
     dictEntry **table;
     //哈希表大小
     unsigned long size;
     //哈希表大小掩码，用于计算索引值
     //总是等于 size-1
     unsigned long sizemask;
     //该哈希表已有节点的数量
     unsigned long used;
}dictht
```
哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：
```
typedef struct dictEntry{
     //键
     void *key;
     //值
     union{
          void *val;
          uint64_tu64;
          int64_ts64;
     }v;
 
     //指向下一个哈希表节点，形成链表
     struct dictEntry *next;
}dictEntry
```


#### 事务
---
事务错误：
一种是exec执行前的错误：如命令语法错误，或者服务器内存超限等问题
另一种是exec执行后的错误，如命令执行错误，如给一个list赋值了string

redis事务原子性只是确保所有命令都执行，不保证所有都执行成功，某一命令执行失败时，其他命令还是会执行的，失败并不会回滚
官方说不用回滚的原因：

 1. redis命令只会在以错误的语法执行时失败（这个问题是在命令queueing时没被检测到），或者赋值给错误的数据类型（字符串类型赋值给list类型），这实际意味着失败的命令是编程错误导致的，还有一种很可能是在开发环境发生的错误而不是生成环境
 2. redis 内部简单和快速是因为他不需要rollback
 3. exec方法会返回每一条命令的执行结果，如果有实际需求，也可手动回滚

watch生命周期：会在exec执行后unwatch，或者连接关闭后unwatch

##### 乐观锁 悲观锁
---
乐观锁：就像他的名字，不会认为数据不会出错，他不会为数据上锁，但是为了保证数据的一致性，
他会在每条记录的后面添加一个标记（类似于版本号），假设A 获取K1这条标记，得到了k1的版本号是1，
并对其进行修改，这个时候B也获取了k1这个数据，当然，B获取的版本号也是1，同样也对k1进行修改，
这个时候，如果B先提交了，那么k1的版本号将会改变成2，这个时候，如果A提交数据，
他会发现自己的版本号与最新的版本号不一致，这个时候A的提交将不会成功，A的做法是重新获取最新的k1的数据，重复修改数据、提交数据。

悲观锁：这个模式将认定数据一定会出错，所以她的做法是将整张表锁起来，这样会有很强的一致性，
但是同时会有极低的并发性（常用语数据库备份工作，类似于表锁）

##### pipeline与muti性能对比 [链接](https://www.jianshu.com/p/20b3a0fc4f55)
---
> multi和pipeline的区别在于multi会将操作都即刻的发送至redis服务端queued起来，每条指令queued的操作都有一次通信开销，执行exec时redis服务端再一口气执行queued队列里的指令，
pipeline则是在客户端本地queued起来，执行exec时一次性的发送给redis服务端，这样只有一次通信开销。比如我有5个incr操作，multi的话这5个incr会有5次通信开销，但pipeline只有一次。

#### 持久化 RDB VS AOF
RDB持久化(默认)：在指定的时间间隔内将内存中的数据写入磁盘，默认二进制文件名为dump.rdb。
```
//可以配置redis在n秒内若超过m个key被修改就自动做快照
save 900 1  #900内如果超过1个key被修改，则进行快照
save 300 10 #300内如果超过10个key被修改，则进行快照

```
RDB文件保存过程：
1. redis调用fork,现在有了子进程和父进程。
2. 父进程继续处理client请求，子进程负责将内存内容写入到临时文件。由于os的写时复制机制（copy on write)父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数 据是fork时刻整个数据库的一个快照。
3. 当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出

优点：
1. 整个redis数据库只有一个文件，方便备份
2. 恢复大数据集时速度比AOF的恢复速度快
3. 写操作是子进程，不干扰父进程处理客户端请求
缺点：
1. 定时备份可能出现数据丢失
2. 数据庞大时，fork子进程可能耗时久

#### 缓存穿透 缓存击穿  缓存雪崩
缓存穿透：故意频繁请求不存在的key，导致一直查数据库
解决方法：
1 布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；
2 查库为空时，缓存空值，设置一个较短的过期时间

缓存击穿：某个key过期时，遇到高并发请求该key，一起查库
解决方法：互斥锁(setnx)，只让拿到锁的请求进行查库存入缓存，其他请求根据实际业务可以直接返回错误或者重试机制


缓存雪崩：在某个时间点，一堆缓存集体过期，并发查库
解决方法：
1 缓存服务要高可用，比如宕机的时候，需要几时切换
2 加入随机过期时间，错开过期时间
3 数据预热，业务上线前先主动跑一遍，把用到的公共数据跑到缓存


#### 参考
[教程](https://www.cnblogs.com/ysocean/tag/Redis%E8%AF%A6%E8%A7%A3/)
[redis设计与实现](http://redisbook.com/preview/sds/different_between_sds_and_c_string.html)


